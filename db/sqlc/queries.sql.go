// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"
	"time"
)

const deleteDocker = `-- name: DeleteDocker :exec
DELETE FROM
    docker
WHERE
    name = ?
`

func (q *Queries) DeleteDocker(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteDocker, name)
	return err
}

const deleteIngestedFilesByEnvironment = `-- name: DeleteIngestedFilesByEnvironment :exec
DELETE FROM
    ingested_files
WHERE
    environment_type = ?
    AND environment_name = ?
`

type DeleteIngestedFilesByEnvironmentParams struct {
	EnvironmentType string
	EnvironmentName string
}

func (q *Queries) DeleteIngestedFilesByEnvironment(ctx context.Context, arg DeleteIngestedFilesByEnvironmentParams) error {
	_, err := q.db.ExecContext(ctx, deleteIngestedFilesByEnvironment, arg.EnvironmentType, arg.EnvironmentName)
	return err
}

const deleteK8s = `-- name: DeleteK8s :exec
DELETE FROM
    k8s
WHERE
    name = ?
`

func (q *Queries) DeleteK8s(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteK8s, name)
	return err
}

const getAllDocker = `-- name: GetAllDocker :many
SELECT
    name, directory, api_url, gui_url, backoffice_url, api_port, gui_port, backoffice_port
FROM
    docker
`

// Docker queries
func (q *Queries) GetAllDocker(ctx context.Context) ([]Docker, error) {
	rows, err := q.db.QueryContext(ctx, getAllDocker)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Docker
	for rows.Next() {
		var i Docker
		if err := rows.Scan(
			&i.Name,
			&i.Directory,
			&i.ApiUrl,
			&i.GuiUrl,
			&i.BackofficeUrl,
			&i.ApiPort,
			&i.GuiPort,
			&i.BackofficePort,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllK8s = `-- name: GetAllK8s :many
SELECT
    name, directory, context, api_url, gui_url, backoffice_url, protocol, tls_enabled
FROM
    k8s
`

// K8s queries
func (q *Queries) GetAllK8s(ctx context.Context) ([]K8s, error) {
	rows, err := q.db.QueryContext(ctx, getAllK8s)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []K8s
	for rows.Next() {
		var i K8s
		if err := rows.Scan(
			&i.Name,
			&i.Directory,
			&i.Context,
			&i.ApiUrl,
			&i.GuiUrl,
			&i.BackofficeUrl,
			&i.Protocol,
			&i.TlsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDockerByName = `-- name: GetDockerByName :one
SELECT
    name, directory, api_url, gui_url, backoffice_url, api_port, gui_port, backoffice_port
FROM
    docker
WHERE
    name = ?
`

func (q *Queries) GetDockerByName(ctx context.Context, name string) (Docker, error) {
	row := q.db.QueryRowContext(ctx, getDockerByName, name)
	var i Docker
	err := row.Scan(
		&i.Name,
		&i.Directory,
		&i.ApiUrl,
		&i.GuiUrl,
		&i.BackofficeUrl,
		&i.ApiPort,
		&i.GuiPort,
		&i.BackofficePort,
	)
	return i, err
}

const getIngestedFilesByEnvironment = `-- name: GetIngestedFilesByEnvironment :many
SELECT
    file_path,
    ingested_at
FROM
    ingested_files
WHERE
    environment_type = ?
    AND environment_name = ?
ORDER BY
    ingested_at DESC
`

type GetIngestedFilesByEnvironmentParams struct {
	EnvironmentType string
	EnvironmentName string
}

type GetIngestedFilesByEnvironmentRow struct {
	FilePath   string
	IngestedAt *time.Time
}

func (q *Queries) GetIngestedFilesByEnvironment(ctx context.Context, arg GetIngestedFilesByEnvironmentParams) ([]GetIngestedFilesByEnvironmentRow, error) {
	rows, err := q.db.QueryContext(ctx, getIngestedFilesByEnvironment, arg.EnvironmentType, arg.EnvironmentName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIngestedFilesByEnvironmentRow
	for rows.Next() {
		var i GetIngestedFilesByEnvironmentRow
		if err := rows.Scan(&i.FilePath, &i.IngestedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getK8sByName = `-- name: GetK8sByName :one
SELECT
    name, directory, context, api_url, gui_url, backoffice_url, protocol, tls_enabled
FROM
    k8s
WHERE
    name = ?
`

func (q *Queries) GetK8sByName(ctx context.Context, name string) (K8s, error) {
	row := q.db.QueryRowContext(ctx, getK8sByName, name)
	var i K8s
	err := row.Scan(
		&i.Name,
		&i.Directory,
		&i.Context,
		&i.ApiUrl,
		&i.GuiUrl,
		&i.BackofficeUrl,
		&i.Protocol,
		&i.TlsEnabled,
	)
	return i, err
}

const getLatestReleaseCache = `-- name: GetLatestReleaseCache :one
SELECT
    id, tag_name, fetched_at
FROM
    latest_release_cache
WHERE
    id = 1
`

func (q *Queries) GetLatestReleaseCache(ctx context.Context) (LatestReleaseCache, error) {
	row := q.db.QueryRowContext(ctx, getLatestReleaseCache)
	var i LatestReleaseCache
	err := row.Scan(&i.ID, &i.TagName, &i.FetchedAt)
	return i, err
}

const insertDocker = `-- name: InsertDocker :one
INSERT INTO
    docker (
        name,
        directory,
        api_url,
        gui_url,
        backoffice_url,
        gui_port,
        api_port,
        backoffice_port
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING
    name, directory, api_url, gui_url, backoffice_url, api_port, gui_port, backoffice_port
`

type InsertDockerParams struct {
	Name           string
	Directory      string
	ApiUrl         string
	GuiUrl         string
	BackofficeUrl  string
	GuiPort        int64
	ApiPort        int64
	BackofficePort int64
}

func (q *Queries) InsertDocker(ctx context.Context, arg InsertDockerParams) (Docker, error) {
	row := q.db.QueryRowContext(ctx, insertDocker,
		arg.Name,
		arg.Directory,
		arg.ApiUrl,
		arg.GuiUrl,
		arg.BackofficeUrl,
		arg.GuiPort,
		arg.ApiPort,
		arg.BackofficePort,
	)
	var i Docker
	err := row.Scan(
		&i.Name,
		&i.Directory,
		&i.ApiUrl,
		&i.GuiUrl,
		&i.BackofficeUrl,
		&i.ApiPort,
		&i.GuiPort,
		&i.BackofficePort,
	)
	return i, err
}

const insertIngestedFile = `-- name: InsertIngestedFile :exec
INSERT INTO
    ingested_files (
        environment_type,
        environment_name,
        file_path,
        ingested_at
    )
VALUES
    (?, ?, ?, CURRENT_TIMESTAMP) ON CONFLICT (environment_type, environment_name, file_path) DO
UPDATE
SET
    ingested_at = CURRENT_TIMESTAMP
`

type InsertIngestedFileParams struct {
	EnvironmentType string
	EnvironmentName string
	FilePath        string
}

func (q *Queries) InsertIngestedFile(ctx context.Context, arg InsertIngestedFileParams) error {
	_, err := q.db.ExecContext(ctx, insertIngestedFile, arg.EnvironmentType, arg.EnvironmentName, arg.FilePath)
	return err
}

const insertK8s = `-- name: InsertK8s :one
INSERT INTO
    k8s (
        name,
        directory,
        context,
        api_url,
        gui_url,
        backoffice_url,
        protocol,
        tls_enabled
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING
    name, directory, context, api_url, gui_url, backoffice_url, protocol, tls_enabled
`

type InsertK8sParams struct {
	Name          string
	Directory     string
	Context       string
	ApiUrl        string
	GuiUrl        string
	BackofficeUrl string
	Protocol      string
	TlsEnabled    bool
}

func (q *Queries) InsertK8s(ctx context.Context, arg InsertK8sParams) (K8s, error) {
	row := q.db.QueryRowContext(ctx, insertK8s,
		arg.Name,
		arg.Directory,
		arg.Context,
		arg.ApiUrl,
		arg.GuiUrl,
		arg.BackofficeUrl,
		arg.Protocol,
		arg.TlsEnabled,
	)
	var i K8s
	err := row.Scan(
		&i.Name,
		&i.Directory,
		&i.Context,
		&i.ApiUrl,
		&i.GuiUrl,
		&i.BackofficeUrl,
		&i.Protocol,
		&i.TlsEnabled,
	)
	return i, err
}

const upsertLatestReleaseCache = `-- name: UpsertLatestReleaseCache :exec
INSERT INTO
    latest_release_cache (id, tag_name, fetched_at)
VALUES
    (1, ?, ?) ON CONFLICT (id) DO
UPDATE
SET
    tag_name = excluded.tag_name,
    fetched_at = excluded.fetched_at
`

type UpsertLatestReleaseCacheParams struct {
	TagName   string
	FetchedAt *time.Time
}

func (q *Queries) UpsertLatestReleaseCache(ctx context.Context, arg UpsertLatestReleaseCacheParams) error {
	_, err := q.db.ExecContext(ctx, upsertLatestReleaseCache, arg.TagName, arg.FetchedAt)
	return err
}
